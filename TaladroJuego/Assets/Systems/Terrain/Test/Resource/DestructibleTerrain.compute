#pragma kernel InitializeTerrain
#pragma kernel ModifyTerrain
#pragma kernel ApplyVisuals

struct TerrainModificationSource
{
	float3 positionWS;
	float radius;
	float strength;
	float falloff;
	uint type;
};

#define MAX_SOURCES 32
uniform StructuredBuffer<TerrainModificationSource> _Sources;
uniform uint _SourceCount;

uniform RWTexture2D<float2> _TerrainResult;
uniform uint _TerrainTypesCount;
uniform float4x4 _ClipToWorldMatrix;

uniform uint4 _TextureOffsetAndSize;

uniform Texture2DArray<float4> _TerrainTextures;
uniform uint4 _TerrainTexturesOffsetAndSize;

uniform RWTexture2D<float4> _TerrainVisuals;

uint2 TextureCoordinatesFromID(uint2 id)
{
	return id + _TextureOffsetAndSize.xy;
}

float2 UVFromID(uint2 id)
{
	float2 uv = id / float2(_TextureOffsetAndSize.zw);
#if UNITY_UV_STARTS_AT_TOP
	return uv * float2(1.0f, -1.0f) + float2(0.0f, 1.0f);
#else
	return uv;
#endif
}

bool IsIDInTexture(uint2 id)
{
	return all((TextureCoordinatesFromID(id) < _TextureOffsetAndSize.zw));
}

float EncodedTerrainTypeFrom(uint type)
{
	return type / float(_TerrainTypesCount);
}

uint TerrainTypeFromEncoded(float encoded)
{
	return uint(encoded * float(_TerrainTypesCount));
};

// https://iquilezles.org/articles/distfunctions
float dot2( in float3 v ) { return dot(v,v); }
float udTriangle( in float3 v1, in float3 v2, in float3 v3, in float3 p )
{
    float3 v21 = v2 - v1; float3 p1 = p - v1;
    float3 v32 = v3 - v2; float3 p2 = p - v2;
    float3 v13 = v1 - v3; float3 p3 = p - v3;
    float3 nor = cross( v21, v13 );

    return sqrt( (sign(dot(cross(v21,nor),p1)) + 
                  sign(dot(cross(v32,nor),p2)) + 
                  sign(dot(cross(v13,nor),p3))<2.0) 
                  ?
                  min( min( 
                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), 
                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), 
                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )
                  :
                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );
}

float sdCone( float3 p, float2 q )
{
  // c is the sin/cos of the angle, h is height
  // Alternatively pass q instead of (c,h),
  // which is the point at the base in 2D
  //float2 q = h*float2(c.x/c.y,-1.0);
    
  float2 w = float2( length(p.xz), p.y );
  float2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );
  float2 b = w - q*float2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );
  float k = sign( q.y );
  float d = min(dot( a, a ),dot(b, b));
  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );
  return sqrt(d)*sign(s);
}

[numthreads(16,16,1)]
void InitializeTerrain(uint3 id : SV_DispatchThreadID)
{
	if (!IsIDInTexture(id.xy))
		return;

	_TerrainResult[id.xy] = float2(1.0f, EncodedTerrainTypeFrom(1));
}

[numthreads(16,16,1)]
void ModifyTerrain(uint3 id : SV_DispatchThreadID)
{
	if (!IsIDInTexture(id.xy))
		return;

	float2 uv = UVFromID(id.xy);
	float4 positionWS = mul(_ClipToWorldMatrix, float4(uv * 2.0f - 1.0f, 0.0f, 1.0f));
	positionWS /= positionWS.w;

	float2 sourcesContribution = 0.0f;
	[unroll]
	for (uint i = 0; i < MAX_SOURCES; i++)
	{
		if (i >= _SourceCount)
			break;
		TerrainModificationSource source = _Sources[i];

		float3 t0 = float3(source.positionWS.xy, 0.0f) + float3(-1.0f, 1.0f, 0.0f);
		float3 t1 = float3(source.positionWS.xy, 0.0f) + float3(1.0f, 1.0f, 0.0f);
		float3 t2 = float3(source.positionWS.xy, 0.0f) + float3(0.0f, -1.0f, 0.0f);

		//float distance = udTriangle(t0, t1, t2, float3(positionWS.xy, 0.0f));
		float distance = max(sdCone(float3(positionWS.xy - source.positionWS.xy, 0.0f), float2(0.5f, 1.0f)), 0.0f);
		float falloff = pow(1.0f - saturate(distance / source.radius), source.falloff);
		sourcesContribution.x += source.strength * falloff;
		sourcesContribution.y += EncodedTerrainTypeFrom(source.type) * falloff;
	}

	sourcesContribution.y /= _SourceCount;

	float2 current = _TerrainResult[id.xy];
	_TerrainResult[id.xy] =
		sourcesContribution.x * sourcesContribution.xy +
		(1.0f - sourcesContribution.x) * current.xy;
}

[numthreads(16,16,1)]
void ApplyVisuals(uint3 id : SV_DispatchThreadID)
{
	if (!IsIDInTexture(id.xy))
		return;

	float2 encoded = _TerrainResult[id.xy];
	uint type = TerrainTypeFromEncoded(encoded.y);

	float3 color = _TerrainTextures[uint3(id.xy % _TerrainTexturesOffsetAndSize.zw, type)].xyz;
	_TerrainVisuals[id.xy] = float4(color, 1.0f);
}